package com.xwc.open.easy.batis.plugin;import com.xwc.open.easy.batis.assistant.AnnotationAssistan;import com.xwc.open.easy.batis.assistant.DefaultPrimaryKeyBuilder;import com.xwc.open.easy.batis.enums.AuditorType;import com.xwc.open.easy.batis.enums.IdType;import com.xwc.open.easy.batis.interfaces.AuditorAware;import com.xwc.open.easy.batis.interfaces.PrimaryKeyBuilder;import com.xwc.open.easy.batis.interfaces.impl.DefaultAuditorAware;import com.xwc.open.easy.batis.meta.Attribute;import com.xwc.open.easy.batis.meta.AuditorAttribute;import com.xwc.open.easy.batis.meta.MethodMate;import org.apache.ibatis.executor.statement.StatementHandler;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.mapping.SqlCommandType;import org.apache.ibatis.plugin.*;import org.apache.ibatis.reflection.MetaObject;import org.apache.ibatis.reflection.SystemMetaObject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.lang.reflect.InvocationTargetException;import java.sql.Statement;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Properties;/** * 创建人：徐卫超 * 时间：2019/9/7 8:17 * 功能： * 备注： */@Intercepts({@Signature(        type = StatementHandler.class,        method = "parameterize",        args = {Statement.class})})public class ParameterizePlugin implements Interceptor {    private static final Logger logger = LoggerFactory.getLogger(ParameterizePlugin.class);    private static Map<String, MethodMate> methodMap = new HashMap<>();    private static final String PARAM_OBJECT = "parameterHandler.parameterObject";    private static final String MAPPED_STATEMENT = "parameterHandler.mappedStatement";    private AuditorAware auditorAware = new DefaultAuditorAware();    private PrimaryKeyBuilder primaryKeyBuilder = new DefaultPrimaryKeyBuilder();    @Override    public Object intercept(Invocation invocation) throws Throwable {        MetaObject metaObject = SystemMetaObject.forObject(invocation.getTarget());        MappedStatement ms = (MappedStatement) metaObject.getValue(MAPPED_STATEMENT);        if (ms.getSqlCommandType() != SqlCommandType.INSERT &&                ms.getSqlCommandType() != SqlCommandType.UPDATE &&                ms.getSqlCommandType() != SqlCommandType.SELECT &&                ms.getSqlCommandType() != SqlCommandType.DELETE) {            return invocation.proceed();        }        MethodMate methodMate = methodMap.get(ms.getId());        if (methodMate == null) {            return invocation.proceed();        }        Object value = metaObject.getValue(PARAM_OBJECT);        //TODO 处理ID属性        setterId(value, ms.getSqlCommandType(), methodMate.getType(), methodMate.getId());        //TODO 处理审计属性        setterAuditor(value, ms.getSqlCommandType(), methodMate.getAuditorAttributeList(), methodMate.isObject());        metaObject.setValue(PARAM_OBJECT, value);        return invocation.proceed();    }    @Override    public Object plugin(Object target) {        Object wrap = Plugin.wrap(target, this);        return wrap;    }    private Object setterId(Object value, SqlCommandType commandType, IdType idType, Attribute attribute) {        if (commandType != SqlCommandType.INSERT) return value;        if (value instanceof Map) {            Map map = (Map) value;            map.forEach((k, v) -> {                if (v instanceof List) {                    List list = (List) v;                    list.forEach(item -> {                        if (!AnnotationAssistan.isDefualtClass(item.getClass())) insertKey(item, idType, attribute);                    });                }            });        } else if (!AnnotationAssistan.isDefualtClass(value.getClass())) {            insertKey(value, idType, attribute);        }        return value;    }    private Object setterAuditor(Object value, SqlCommandType commandType, List<AuditorAttribute> attributeList, boolean isObject) {       if (commandType != SqlCommandType.INSERT) return value;        //处理插入数据是数组        if (value instanceof Map) {            Map map = (Map) value;            map.forEach((k, v) -> {                if (v instanceof List) {                    List list = (List) v;                    list.forEach(item -> insertObjectAuditor(item, attributeList, commandType));                }else {                    //                }            });        }else if(!AnnotationAssistan.isDefualtClass(value.getClass())){            attributeList.forEach(item -> insertObjectAuditor(value, attributeList, commandType));        }        return value;    }    private void insertKey(Object value, IdType idType, Attribute attribute) {        if (idType == IdType.UUID) {            setterIdValue(value, attribute);        }    }    private void insertObjectAuditor(Object value, List<AuditorAttribute> attributeList, SqlCommandType sqlCommandType) {        attributeList.forEach(auditor -> {            if (sqlCommandType == SqlCommandType.INSERT) {                if (auditor.getType() == AuditorType.CREATE_ID) {                    setterAuditorValue(value, auditor, auditorAware.id());                } else if (auditor.getType() == AuditorType.CREATE_NAME) {                    setterAuditorValue(value, auditor, auditorAware.name());                } else if (auditor.getType() == AuditorType.CREATE_TIME) {                    setterAuditorValue(value, auditor, auditorAware.time());                }            }            if (auditor.getType() == AuditorType.UPDATE_ID) {                setterAuditorValue(value, auditor, auditorAware.id());            } else if (auditor.getType() == AuditorType.UPDATE_NAME) {                setterAuditorValue(value, auditor, auditorAware.name());            } else if (auditor.getType() == AuditorType.UPDATE_TIME) {                setterAuditorValue(value, auditor, auditorAware.time());            }        });    }    private void setterAuditorValue(Object object, Attribute attribute, Object value) {        try {            attribute.getSetter().invoke(object, value);        } catch (IllegalAccessException | InvocationTargetException e) {            e.printStackTrace();        }    }    private void setterIdValue(Object value, Attribute attribute) {        try {            attribute.getSetter().invoke(value, primaryKeyBuilder.uuid());        } catch (IllegalAccessException | InvocationTargetException e) {            e.printStackTrace();        }    }    @Override    public void setProperties(Properties properties) {    }    public static void addMethodMate(String methodId, MethodMate mate) {        methodMap.put(methodId, mate);    }}